#!/bin/bash
export TZ="America/El_Salvador"
export LANG=es_ES.UTF-8
timedatectl set-timezone America/El_Salvador 2>/dev/null || true
export TERM=xterm-256color
export REGISTROS="/root/reg.txt"
export HISTORIAL="/root/log.txt"
export PIDFILE="/var/run/mon.pid"


##DEMOOOOOOOOOOOO 

    

    
    function crear_registro() {
    clear
    echo -e "${VIOLETA}===== ü§™ CREAR USUARIO SSH =====${NC}"

    # Definir rutas expl√≠citamente
    REGISTROS="/root/reg.txt"
    HISTORIAL="/root/log.txt"

    # Verificar permisos de escritura en REGISTROS
    if [[ ! -f "$REGISTROS" ]]; then
        touch "$REGISTROS" 2>/dev/null || {
            echo -e "${ROJO}‚ùå No se pudo crear $REGISTROS. Revisa permisos y sistema de archivos.${NC}"
            read -p "$(echo -e ${CIAN}Presiona Enter para continuar...${NC})"
            return 1
        }
    fi
    if [[ ! -w "$REGISTROS" ]]; then
        echo -e "${ROJO}‚ùå No se puede escribir en $REGISTROS. Revisa permisos.${NC}"
        read -p "$(echo -e ${CIAN}Presiona Enter para continuar...${NC})"
        return 1
    fi

    # Verificar permisos de escritura en HISTORIAL
    if [[ ! -f "$HISTORIAL" ]]; then
        touch "$HISTORIAL" 2>/dev/null || {
            echo -e "${ROJO}‚ùå No se pudo crear $HISTORIAL. Revisa permisos y sistema de archivos.${NC}"
            echo "$(date '+%Y-%m-%d %H:%M:%S'):No se pudo crear $HISTORIAL" >> "$HISTORIAL" 2>/dev/null
            read -p "$(echo -e ${CIAN}Presiona Enter para continuar...${NC})"
            return 1
        }
    fi
    if [[ ! -w "$HISTORIAL" ]]; then
        echo -e "${ROJO}‚ùå No se puede escribir en $HISTORIAL. Revisa permisos.${NC}"
        echo "$(date '+%Y-%m-%d %H:%M:%S'):No se puede escribir en $HISTORIAL" >> "$HISTORIAL" 2>/dev/null
        read -p "$(echo -e ${CIAN}Presiona Enter para continuar...${NC})"
        return 1
    fi

    # Verificar sistema de archivos
    if mount | grep /root | grep -q ro; then
        echo -e "${ROJO}‚ùå El directorio /root est√° montado como solo lectura. Remonta con 'mount -o remount,rw /root'.${NC}"
        echo "$(date '+%Y-%m-%d %H:%M:%S'):Directorio /root en solo lectura" >> "$HISTORIAL" 2>/dev/null
        read -p "$(echo -e ${CIAN}Presiona Enter para continuar...${NC})"
        return 1
    fi

    # Verificar espacio en disco
    if ! df -h /root | grep -q '[0-9]'; then
        echo -e "${ROJO}‚ùå No hay espacio en disco en /root. Libera espacio e intenta de nuevo.${NC}"
        echo "$(date '+%Y-%m-%d %H:%M:%S'):No hay espacio en disco en /root" >> "$HISTORIAL" 2>/dev/null
        read -p "$(echo -e ${CIAN}Presiona Enter para continuar...${NC})"
        return 1
    fi

    # Agregar /bin/false a /etc/shells si no existe (necesario para logins con Dropbear/SSH tunneling)
    if ! grep -q '^/bin/false$' /etc/shells; then
        echo "/bin/false" >> /etc/shells
        echo "$(date '+%Y-%m-%d %H:%M:%S'):/bin/false agregado a /etc/shells para permitir conexiones." >> "$HISTORIAL"
    fi

    # Leer nombre del usuario
    while true; do
        read -p "$(echo -e ${AZUL}üë§ Nombre del usuario: ${NC})" USUARIO
        [[ -z "$USUARIO" ]] && echo -e "${ROJO}‚ùå Ingresa un nombre v√°lido.${NC}" && continue
        if id "$USUARIO" &>/dev/null; then
            echo -e "${ROJO}‚ö†Ô∏è El usuario '$USUARIO' ya existe en el sistema.${NC}"
            continue
        fi
        if grep -qw "^$USUARIO:" "$REGISTROS"; then
            echo -e "${ROJO}‚ö†Ô∏è Ya existe un registro con ese nombre en $REGISTROS.${NC}"
            continue
        fi
        break
    done

    # Leer contrase√±a
    read -p "$(echo -e ${AZUL}üîë Contrase√±a: ${NC})" CLAVE
    [[ -z "$CLAVE" ]] && echo -e "${ROJO}‚ùå La contrase√±a no puede estar vac√≠a.${NC}" && read -p "$(echo -e ${CIAN}Presiona Enter para continuar...${NC})" && return 1

    # Leer d√≠as de validez
    while true; do
        read -p "$(echo -e ${AZUL}üìÖ D√≠as de validez: ${NC})" DIAS
        [[ "$DIAS" =~ ^[0-9]+$ && "$DIAS" -ge 0 ]] && break
        echo -e "${ROJO}‚ùå Ingresa un n√∫mero v√°lido (0 o m√°s).${NC}"
    done

    # Leer n√∫mero de m√≥viles
    while true; do
        read -p "$(echo -e ${AZUL}üì± ¬øCu√°ntos m√≥viles? ${NC})" MOVILES
        [[ "$MOVILES" =~ ^[1-9][0-9]{0,2}$ && "$MOVILES" -le 999 ]] && break
        echo -e "${ROJO}‚ùå Ingresa un n√∫mero entre 1 y 999.${NC}"
    done

    # Calcular fechas con ajuste para expiraci√≥n a medianoche siguiente
    DIAS_EXPIRACION=$(( DIAS == 0 ? 1 : DIAS + 1 ))
    FECHA_CREACION=$(date +"%Y-%m-%d %H:%M:%S")
    FECHA_CREACION_FILE=$(date +"%Y-%m-%d_%H%M%S")  # Formato sin dos puntos: YYYY-MM-DD_HHMMSS
    EXPIRA_FECHA=$(date -d "+$DIAS_EXPIRACION days" +"%Y-%m-%d")
    FECHA_FORMAT=$(date -d "+$DIAS days" +"%d/%B/%Y" | awk '{print $1 "/" tolower($2) "/" $3}' | sed 's/\/*$//')

    # Agregar al REGISTROS con depuraci√≥n
    echo "Debug: Writing to reg.txt: ${USUARIO}:${CLAVE}:${FECHA_FORMAT}:${DIAS} d√≠as:${MOVILES}:${FECHA_CREACION_FILE}" >> "/tmp/debug.log"
    echo "${USUARIO}:${CLAVE}:${FECHA_FORMAT}:${DIAS} d√≠as:${MOVILES}:${FECHA_CREACION_FILE}" >> "$REGISTROS"
    sync

    # Verificar escritura
    if ! grep -q "^${USUARIO}:${CLAVE}:${FECHA_FORMAT}:${DIAS} d√≠as:${MOVILES}:${FECHA_CREACION_FILE}$" "$REGISTROS"; then
        echo "$(date '+%Y-%m-%d %H:%M:%S'):Error: Registro de '$USUARIO' no se encontr√≥ en $REGISTROS tras escritura." >> "$HISTORIAL"
        echo "$(date '+%Y-%m-%d %H:%M:%S'):Contenido de $REGISTROS tras intento de escritura:" >> "$HISTORIAL"
        cat "$REGISTROS" >> "$HISTORIAL" 2>/dev/null
        echo -e "${ROJO}‚ùå Error: Fall√≥ la escritura del registro en $REGISTROS. Intenta de nuevo.${NC}"
        read -p "$(echo -e ${CIAN}Presiona Enter para continuar...${NC})"
        return 1
    fi

    # Crear usuario
    if ! useradd -M -s /bin/false "$USUARIO"; then
        sed -i "/^${USUARIO}:/d" "$REGISTROS"
        sync
        echo "$(date '+%Y-%m-%d %H:%M:%S'):Error creando usuario '$USUARIO' en el sistema. Registro eliminado." >> "$HISTORIAL"
        echo -e "${ROJO}‚ùå Error creando el usuario en el sistema.${NC}"
        read -p "$(echo -e ${CIAN}Presiona Enter para continuar...${NC})"
        return 1
    fi

    # Establecer contrase√±a
    if ! echo "$USUARIO:$CLAVE" | chpasswd; then
        userdel -r "$USUARIO" 2>/dev/null
        sed -i "/^${USUARIO}:/d" "$REGISTROS"
        sync
        echo "$(date '+%Y-%m-%d %H:%M:%S'):Error estableciendo contrase√±a para '$USUARIO'. Registro y usuario eliminados." >> "$HISTORIAL"
        echo -e "${ROJO}‚ùå Fall√≥ el cambio de contrase√±a. Registro revertido.${NC}"
        read -p "$(echo -e ${CIAN}Presiona Enter para continuar...${NC})"
        return 1
    fi

    # Configurar expiraci√≥n
    if ! usermod -e "$EXPIRA_FECHA" "$USUARIO"; then
        userdel -r "$USUARIO" 2>/dev/null
        sed -i "/^${USUARIO}:/d" "$REGISTROS"
        sync
        echo "$(date '+%Y-%m-%d %H:%M:%S'):Error configurando expiraci√≥n para '$USUARIO'. Registro y usuario eliminados." >> "$HISTORIAL"
        echo -e "${ROJO}‚ùå Error configurando expiraci√≥n. Registro eliminado.${NC}"
        read -p "$(echo -e ${CIAN}Presiona Enter para continuar...${NC})"
        return 1
    fi

    # Registrar acci√≥n en HISTORIAL
    echo "$(date '+%Y-%m-%d %H:%M:%S'):Usuario creado:$USUARIO" >> "$HISTORIAL"

    # Mostrar resultado final
    FECHA_CREACION_DISPLAY=$(echo "$FECHA_CREACION" | sed 's/_/ /')
    echo -e "${VERDE}‚úÖ  Usuario creado correctamente:${NC}"
    echo -e "${AZUL}üë§ Usuario:${AMARILLO} $USUARIO${NC}"
    echo -e "${AZUL}üîë Clave:   ${AMARILLO}$CLAVE${NC}"
    echo -e "${AZUL}üìÖ Expira:  ${AMARILLO}${FECHA_FORMAT}${NC}"
    echo -e "${AZUL}üì± L√≠mite m√≥viles: ${AMARILLO}$MOVILES${NC}"
    echo -e "${AZUL}üìÖ Creado:  ${AMARILLO}${FECHA_CREACION_DISPLAY}${NC}"
    echo -e "${VIOLETA}===== üìù RESUMEN DE REGISTRO =====${NC}"
    echo -e "${AMARILLO}üë§ Usuario    üìÖ Expira          ‚è≥  D√≠as       üì± M√≥viles   üìÖ Creado${NC}"
    echo -e "${CIAN}---------------------------------------------------------------${NC}"
    printf "${VERDE}%-12s %-20s %-13s %-12s %-20s${NC}\n" "$USUARIO:$CLAVE" "$FECHA_FORMAT" "$DIAS d√≠as" "$MOVILES" "$FECHA_CREACION_DISPLAY"
    echo -e "${CIAN}===============================================================${NC}"
    read -p "$(echo -e ${CIAN}Presiona Enter para continuar...${NC})"
}

function monitorear_conexiones() {
    LOG="/var/log/monitoreo_conexiones.log"
    REGISTROS="/root/reg.txt"
    HISTORIAL="/root/log.txt"
    INTERVALO=5

    while true; do
        [[ ! -f "$REGISTROS" ]] && { echo "$(date '+%Y-%m-%d %H:%M:%S'): No existe $REGISTROS." >> "$LOG"; sleep "$INTERVALO"; continue; }

        TEMP_FILE=$(mktemp "${REGISTROS}.tmp.XXXXXX") || { echo "$(date '+%Y-%m-%d %H:%M:%S'): Error archivo temporal." >> "$LOG"; sleep "$INTERVALO"; continue; }
        TEMP_FILE_NEW=$(mktemp "${REGISTROS}.tmp.new.XXXXXX") || { rm -f "$TEMP_FILE"; echo "$(date '+%Y-%m-%d %H:%M:%S'): Error archivo temporal nuevo." >> "$LOG"; sleep "$INTERVALO"; continue; }
        cp "$REGISTROS" "$TEMP_FILE" 2>/dev/null || { rm -f "$TEMP_FILE" "$TEMP_FILE_NEW"; echo "$(date '+%Y-%m-%d %H:%M:%S'): Error copiando $REGISTROS." >> "$LOG"; sleep "$INTERVALO"; continue; }
        > "$TEMP_FILE_NEW"

        while IFS=':' read -r USUARIO CLAVE EXPIRA DURACION MOVILES PRIMER_LOGIN; do
            [[ -z "$USUARIO" ]] && continue
            # Limpiar barras adicionales en EXPIRA
            EXPIRA=$(echo "$EXPIRA" | sed 's/\/*$//')
            # Convertir PRIMER_LOGIN al formato con espacios y dos puntos para c√°lculos
            PRIMER_LOGIN=$(echo "$PRIMER_LOGIN" | sed 's/_/ /; s/\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)$/\1:\2:\3/')

            if id "$USUARIO" &>/dev/null; then
                CONEXIONES=$(( $(ps -u "$USUARIO" -o comm= | grep -c "^sshd$") + $(ps -u "$USUARIO" -o comm= | grep -c "^dropbear$") ))
                MOVILES_NUM=$(echo "$MOVILES" | grep -oE '[0-9]+' || echo "1")
                [[ -n $(grep "^$USUARIO:!" /etc/shadow) ]] && CONEXIONES=0

                if [[ $CONEXIONES -gt $MOVILES_NUM ]]; then
                    PIDS=($(ps -u "$USUARIO" -o pid=,comm= | awk '$2=="sshd" || $2=="dropbear"{print $1}' | tail -n +$((MOVILES_NUM+1))))
                    for PID in "${PIDS[@]}"; do
                        kill -9 "$PID" 2>/dev/null
                        echo "$(date '+%Y-%m-%d %H:%M:%S'): Sesi√≥n extra de '$USUARIO' (PID $PID) cerrada." >> "$LOG"
                    done
                fi

                NEW_PRIMER_LOGIN="$PRIMER_LOGIN"
                DURACION_CONECTADO=""

                TMP_STATUS="/tmp/status_${USUARIO}.tmp"

                if [[ $CONEXIONES -gt 0 ]]; then
                    if [[ -z "$PRIMER_LOGIN" || ! -f "$TMP_STATUS" ]]; then
                        NEW_PRIMER_LOGIN=$(date +"%Y-%m-%d %H:%M:%S")
                        echo "$NEW_PRIMER_LOGIN" > "$TMP_STATUS"
                        echo "$(date '+%Y-%m-%d %H:%M:%S'): $USUARIO conectado en $NEW_PRIMER_LOGIN." >> "$LOG"
                    fi

                    # Calcular duraci√≥n en vivo
                    HORA_CONEXION=$(cat "$TMP_STATUS" 2>/dev/null || echo "$NEW_PRIMER_LOGIN")
                    if [[ -n "$HORA_CONEXION" ]]; then
                        START_SECONDS=$(date -d "$HORA_CONEXION" +%s 2>/dev/null)
                        NOW_SECONDS=$(date +%s)
                        if [[ -n "$START_SECONDS" ]]; then
                            DURATION_SECONDS=$(( NOW_SECONDS - START_SECONDS ))
                            DURACION_CONECTADO=$(printf '%02d:%02d:%02d' $((DURATION_SECONDS/3600)) $(((DURATION_SECONDS%3600)/60)) $((DURATION_SECONDS%60)))
                        fi
                    fi

                elif [[ -n "$PRIMER_LOGIN" || -f "$TMP_STATUS" ]]; then
                    HORA_CONEXION=$(cat "$TMP_STATUS" 2>/dev/null || echo "$PRIMER_LOGIN")
                    if [[ -n "$HORA_CONEXION" ]]; then
                        HORA_DESCONEXION=$(date +"%Y-%m-%d %H:%M:%S")
                        START_SECONDS=$(date -d "$HORA_CONEXION" +%s 2>/dev/null)
                        END_SECONDS=$(date -d "$HORA_DESCONEXION" +%s 2>/dev/null)
                        if [[ -n "$START_SECONDS" && -n "$END_SECONDS" ]]; then
                            DURATION_SECONDS=$((END_SECONDS - START_SECONDS))
                            DURATION=$(printf '%02d:%02d:%02d' $((DURATION_SECONDS/3600)) $(((DURATION_SECONDS%3600)/60)) $((DURATION_SECONDS%60)))
                            echo "$USUARIO|$HORA_CONEXION|$HORA_DESCONEXION|$DURATION" >> "$HISTORIAL"
                            echo "$(date '+%Y-%m-%d %H:%M:%S'): $USUARIO desconectado. Duraci√≥n: $DURATION." >> "$LOG"
                        fi
                    fi
                    rm -f "$TMP_STATUS" 2>/dev/null
                    NEW_PRIMER_LOGIN=""
                    DURACION_CONECTADO=""
                fi

                # Convertir NEW_PRIMER_LOGIN a formato sin dos puntos para escribir en reg.txt
                NEW_PRIMER_LOGIN_FILE=$(echo "$NEW_PRIMER_LOGIN" | sed 's/ /_/; s/:\([0-9][0-9]\):\([0-9][0-9]\)$/_\1\2/')
                if [[ -n "$NEW_PRIMER_LOGIN" && -n "$DURACION_CONECTADO" ]]; then
                    echo "${USUARIO}:${CLAVE}:${EXPIRA}:${DURACION}:${MOVILES}:${NEW_PRIMER_LOGIN_FILE}|${DURACION_CONECTADO}" >> "$TEMP_FILE_NEW"
                else
                    echo "${USUARIO}:${CLAVE}:${EXPIRA}:${DURACION}:${MOVILES}:${NEW_PRIMER_LOGIN_FILE}" >> "$TEMP_FILE_NEW"
                fi

            else
                # Mantener PRIMER_LOGIN en formato sin dos puntos
                PRIMER_LOGIN_FILE=$(echo "$PRIMER_LOGIN" | sed 's/ /_/; s/:\([0-9][0-9]\):\([0-9][0-9]\)$/_\1\2/')
                echo "${USUARIO}:${CLAVE}:${EXPIRA}:${DURACION}:${MOVILES}:${PRIMER_LOGIN_FILE}" >> "$TEMP_FILE_NEW"
            fi
        done < "$TEMP_FILE"

        mv "$TEMP_FILE_NEW" "$REGISTROS" 2>/dev/null && sync || { echo "$(date '+%Y-%m-%d %H:%M:%S'): Error reemplazando $REGISTROS." >> "$LOG"; rm -f "$TEMP_FILE" "$TEMP_FILE_NEW"; sleep "$INTERVALO"; continue; }
        rm -f "$TEMP_FILE" 2>/dev/null
        sleep "$INTERVALO"
    done
}

  function verificar_online() {
    clear
    echo -e "${AZUL_SUAVE}===== ‚úÖ USUARIOS ONLINE =====${NC}"

    # Definir colores
    AZUL_SUAVE='\033[38;5;45m'
    SOFT_PINK='\033[38;5;211m'
    PASTEL_BLUE='\033[38;5;153m'
    LILAC='\033[38;5;183m'
    SOFT_CORAL='\033[38;5;217m'
    HOT_PINK='\033[38;5;198m'
    PASTEL_PURPLE='\033[38;5;189m'
    MINT_GREEN='\033[38;5;159m'
    NC='\033[0m'

    declare -A month_map=(
        ["Jan"]="enero" ["Feb"]="febrero" ["Mar"]="marzo" ["Apr"]="abril"
        ["May"]="mayo" ["Jun"]="junio" ["Jul"]="julio" ["Aug"]="agosto"
        ["Sep"]="septiembre" ["Oct"]="octubre" ["Nov"]="noviembre" ["Dec"]="diciembre"
    )

    if [[ ! -f "$HISTORIAL" ]]; then
        touch "$HISTORIAL"
    fi
    if [[ ! -f "$REGISTROS" ]]; then
        echo -e "${HOT_PINK}‚ùå No hay registros de usuarios. üìÇ${NC}"
        read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
        return 1
    fi

    # Centrar texto en un ancho dado
    center_value() {
        local value="$1"
        local width="$2"
        local len=${#value}
        local padding_left=$(( (width - len) / 2 ))
        local padding_right=$(( width - len - padding_left ))
        printf "%*s%s%*s" "$padding_left" "" "$value" "$padding_right" ""
    }

    printf "${AMARILLO}%-14s ${AMARILLO}%-12s ${AMARILLO}%-10s ${AMARILLO}%-25s${NC}\n" \
        "üë§ USUARIO"   "‚úÖ CONEXIONES"   "üì± M√ìVILES"   "‚è∞ TIEMPO CONECTADO"
    echo -e "${LILAC}-----------------------------------------------------------------${NC}"

    TOTAL_CONEXIONES=0
    TOTAL_USUARIOS=0
    INACTIVOS=0

    while IFS=':' read -r USUARIO CLAVE EXPIRA DURACION MOVILES PRIMER_LOGIN; do
        if id "$USUARIO" &>/dev/null; then
            ((TOTAL_USUARIOS++))
            ESTADO="‚òëÔ∏è 0"
            DETALLES="   üò¥ Nunca conectado"
            COLOR_ESTADO="${ROJO}"
            MOVILES_NUM=$(echo "$MOVILES" | grep -oE '[0-9]+' || echo "1")
            MOVILES_CENTRADO=$(center_value "  üì≤ $MOVILES_NUM" 10)

            if grep -q "^$USUARIO:!" /etc/shadow; then
                DETALLES="üîí Usuario bloqueado"
                ((INACTIVOS++))
                COLOR_ESTADO="${ROJO}"
                ESTADO="üî¥ BLOQ"
            else
                CONEXIONES_SSH=$(ps -u "$USUARIO" -o comm= | grep -c "^sshd$")
                CONEXIONES_DROPBEAR=$(ps -u "$USUARIO" -o comm= | grep -c "^dropbear$")
                CONEXIONES=$((CONEXIONES_SSH + CONEXIONES_DROPBEAR))
                if [[ $CONEXIONES -gt 0 ]]; then
                    ESTADO="‚úÖ $CONEXIONES"
                    COLOR_ESTADO="${MINT_GREEN}"
                    TOTAL_CONEXIONES=$((TOTAL_CONEXIONES + CONEXIONES))

                    TMP_STATUS="/tmp/status_${USUARIO}.tmp"
if [[ -f "$TMP_STATUS" ]]; then
    PRIMER_LOGIN_TMP=$(cat "$TMP_STATUS")
else
    PRIMER_LOGIN_TMP="$PRIMER_LOGIN"
fi

if [[ -n "$PRIMER_LOGIN_TMP" ]]; then
    START=$(date -d "$PRIMER_LOGIN_TMP" +%s 2>/dev/null)
    if [[ $? -eq 0 && -n "$START" ]]; then
        CURRENT=$(date +%s)
        ELAPSED_SEC=$((CURRENT - START))
        H=$((ELAPSED_SEC / 3600))
        M=$(((ELAPSED_SEC % 3600) / 60))
        S=$((ELAPSED_SEC % 60))
        DETALLES=$(printf "‚è∞ %02d:%02d:%02d" $H $M $S)
    else
        DETALLES="‚è∞ Tiempo no disponible"
    fi
else
    DETALLES="‚è∞ Tiempo no disponible"
fi
                else
                    ULTIMO_LOGOUT=$(grep "^$USUARIO|" "$HISTORIAL" | tail -1 | awk -F'|' '{print $3}' | grep -E '^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$')
                    if [[ -n "$ULTIMO_LOGOUT" ]]; then
                        ULTIMO_LOGOUT_FMT=$(date -d "$ULTIMO_LOGOUT" +"%d de %B %I:%M %p" 2>/dev/null | awk '{print $1 " de " tolower($2) " " $3 ":" $4 " " tolower($5)}')
                        if [[ $? -eq 0 && -n "$ULTIMO_LOGOUT_FMT" ]]; then
                            for k in "${!month_map[@]}"; do
                                ULTIMO_LOGOUT_FMT=${ULTIMO_LOGOUT_FMT/${month_map[$k]}/${month_map[$k]}}
                            done
                            DETALLES="   üìÖ √öltima: $ULTIMO_LOGOUT_FMT"
                        else
                            DETALLES="   üò¥ Nunca conectado"
                        fi
                    else
                        DETALLES="   üò¥ Nunca conectado"
                    fi
                    ((INACTIVOS++))
                fi
            fi
        printf "${AMARILLO}%-14s ${COLOR_ESTADO}%-12s ${VERDE}%-10s ${AZUL_SUAVE}%-35s${NC}\n" \
    "$USUARIO" "$ESTADO" "$MOVILES_CENTRADO" "$DETALLES"

        fi
    done < "$REGISTROS"

    echo
    echo -e "${CIAN}Total de Online: ${AMARILLO}${TOTAL_CONEXIONES}${NC} ${CIAN} Total usuarios: ${AMARILLO}${TOTAL_USUARIOS}${NC} ${CIAN} Inactivos: ${AMARILLO}${INACTIVOS}${NC}"
    echo -e "${ROJO}================================================${NC}"
    read -p "$(echo -e ${VIOLETA}Presiona Enter para continuar...${NC})"
}
                    
                    
                    


# Iniciar monitoreo de conexiones con nohup si no est√° corriendo
if [[ ! -f "/var/run/mon.pid" ]] || ! ps -p "$(cat "/var/run/mon.pid" 2>/dev/null)" >/dev/null 2>&1; then
    rm -f "/var/run/mon.pid"
    nohup bash -c "source $0; monitorear_conexiones" >> /var/log/monitoreo_conexiones.log 2>&1 &
    sleep 1
    if ps -p $! >/dev/null 2>&1; then
        echo $! > "/var/run/mon.pid"
        echo -e "${MINT_GREEN}üöÄ Monitoreo iniciado en segundo plano (PID: $!).${NC}"
    else
        echo -e "${HOT_PINK}‚ùå Error al iniciar el monitoreo. Revisa /var/log/monitoreo_conexiones.log.${NC}"
    fi
else
    echo -e "${SOFT_CORAL}‚ö†Ô∏è Monitoreo ya est√° corriendo (PID: $(cat "/var/run/mon.pid")).${NC}"
fi


function barra_sistema() {
    # Definici√≥n colores seg√∫n tu estilo
    BLANCO='\033[97m'
    AZUL='\033[94m'
    MAGENTA='\033[95m'
    ROJO='\033[91m'
    AMARILLO='\033[93m'
    NC='\033[0m'

    REGISTROS="/root/reg.txt"
    HISTORIAL="/root/log.txt"

    MEM_TOTAL=$(free -m | awk '/^Mem:/ {print $2}')
    MEM_USO=$(free -m | awk '/^Mem:/ {print $3}')
    MEM_LIBRE=$(free -m | awk '/^Mem:/ {print $4}')
    MEM_DISPONIBLE=$(free -m | awk '/^Mem:/ {print $7}')

    MEM_PORC=$(awk "BEGIN {printf \"%.2f\", ($MEM_USO/$MEM_TOTAL)*100}")

    human() {
        local value=$1
        if [ "$value" -ge 1024 ]; then
            awk "BEGIN {printf \"%.1fG\", $value/1024}"
        else
            echo "${value}M"
        fi
    }

    MEM_TOTAL_H=$(human "$MEM_TOTAL")
    MEM_LIBRE_H=$(human "$MEM_LIBRE")
    MEM_USO_H=$(human "$MEM_USO")
    MEM_DISPONIBLE_H=$(human "$MEM_DISPONIBLE")

    CPU_PORC=$(top -bn1 | grep "Cpu(s)" | awk '{print $2 + $4}')
    CPU_PORC=$(awk "BEGIN {printf \"%.0f\", $CPU_PORC}")

    CPU_MHZ=$(awk -F': ' '/^cpu MHz/ {print $2; exit}' /proc/cpuinfo)
    [[ -z "$CPU_MHZ" ]] && CPU_MHZ="Desconocido"

    if command -v curl &>/dev/null; then
        IP_PUBLICA=$(curl -s ifconfig.me)
    elif command -v wget &>/dev/null; then
        IP_PUBLICA=$(wget -qO- ifconfig.me)
    else
        IP_PUBLICA="No disponible"
    fi

    FECHA_ACTUAL=$(date +"%Y-%m-%d %I:%M %p")
    FECHA_ACTUAL_DIA=$(date +%F)

    TOTAL_CONEXIONES=0
    TOTAL_USUARIOS=0
    USUARIOS_EXPIRAN=()

    if [[ -f "$REGISTROS" ]]; then
        while IFS=':' read -r USUARIO CLAVE EXPIRA DIAS MOVILES CREADO; do
            if id "$USUARIO" &>/dev/null; then
                CONEXIONES_SSH=$(ps -u "$USUARIO" -o comm= | grep -c "^sshd$")
                CONEXIONES_DROPBEAR=$(ps -u "$USUARIO" -o comm= | grep -c "^dropbear$")
                CONEXIONES=$((CONEXIONES_SSH + CONEXIONES_DROPBEAR))
                TOTAL_CONEXIONES=$((TOTAL_CONEXIONES + CONEXIONES))
                ((TOTAL_USUARIOS++))

                # Calcular d√≠as restantes
                DIAS_NUM=$(echo "$DIAS" | grep -oE '^[0-9]+')
                if [[ -n "$CREADO" ]]; then
                    # Manejar ambos formatos: "2025-08-09_10-49-50" y "2025-08-09 10:49:50"
                    if [[ "$CREADO" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{2}-[0-9]{2}-[0-9]{2}$ ]]; then
                        fecha_creacion=$(echo "$CREADO" | awk -F'[_-]' '{print $1"-"$2"-"$3" "$4":"$5":"$6}')
                        fecha_creacion_secs=$(date -d "$fecha_creacion" +%s 2>/dev/null)
                    else
                        fecha_creacion_secs=$(date -d "$CREADO" +%s 2>/dev/null)
                    fi
                    if [[ -z "$fecha_creacion_secs" ]]; then
                        fecha_creacion_secs=$(date +%s)
                        CREADO=$(date +"%Y-%m-%d_%H-%M-%S")
                        sed -i "s/^${USUARIO}:${CLAVE}:${EXPIRA}:${DIAS}:${MOVILES}:.*/${USUARIO}:${CLAVE}:${EXPIRA}:${DIAS}:${MOVILES}:${CREADO}/" "$REGISTROS"
                        sync
                        echo "$(date '+%Y-%m-%d %H:%M:%S'):Formato de fecha inv√°lido para '$USUARIO'. Actualizado a $CREADO." >> "$HISTORIAL"
                    fi
                    fecha_actual=$(date +%s)
                    dias_transcurridos=$(( (fecha_actual - fecha_creacion_secs) / 86400 ))
                    DIAS_RESTANTES=$(( DIAS_NUM - dias_transcurridos ))
                    [[ $DIAS_RESTANTES -lt 0 ]] && DIAS_RESTANTES=0
                else
                    DIAS_RESTANTES="$DIAS_NUM"
                    CREADO=$(date +"%Y-%m-%d_%H-%M-%S")
                    sed -i "s/^${USUARIO}:${CLAVE}:${EXPIRA}:${DIAS}:${MOVILES}:.*/${USUARIO}:${CLAVE}:${EXPIRA}:${DIAS}:${MOVILES}:${CREADO}/" "$REGISTROS"
                    sync
                    echo "$(date '+%Y-%m-%d %H:%M:%S'):Fecha de creaci√≥n vac√≠a para '$USUARIO'. Actualizada a $CREADO." >> "$HISTORIAL"
                fi

                # Guardar usuarios con 0 d√≠as, con colores
                if [[ $DIAS_RESTANTES -eq 0 ]]; then
                    USUARIOS_EXPIRAN+=("${BLANCO}${USUARIO}${NC} ${AMARILLO}0 D√≠as${NC}")
                fi
            fi
        done < "$REGISTROS"
    fi

    if [[ -f /etc/os-release ]]; then
        SO_NAME=$(grep '^PRETTY_NAME=' /etc/os-release | cut -d= -f2- | tr -d '"')
    else
        SO_NAME=$(uname -o)
    fi

    # Imprimir el men√∫ principal
    echo -e "${AZUL}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${BLANCO} üíæ TOTAL: ${AMARILLO}${MEM_TOTAL_H}${NC} ‚àò ${BLANCO}üíø DISPONIBLE: ${AMARILLO}${MEM_DISPONIBLE_H}${NC} ‚àò ${BLANCO}‚ö° EN USO: ${AMARILLO}${MEM_USO_H}${NC}"
    echo -e "${BLANCO} üìä U/RAM: ${AMARILLO}${MEM_PORC}%${NC} ‚àò ${BLANCO}üñ•Ô∏è U/CPU: ${AMARILLO}${CPU_PORC}%${NC} ‚àò ${BLANCO}üîß CPU MHz: ${AMARILLO}${CPU_MHZ}${NC}"
    echo -e "${AZUL}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${BLANCO} üåç IP: ${AMARILLO}${IP_PUBLICA}${NC} ‚àò ${BLANCO}üïí FECHA: ${AMARILLO}${FECHA_ACTUAL}${NC}"
    echo -e "${MAGENTA}üòëüòë ùêåùêúùêúùêöùê´ùê≠ùê°ùêûùê≤${NC}"
    echo -e "${BLANCO}üîó ONLINE:${AMARILLO}${TOTAL_CONEXIONES}${NC}   ${BLANCO}üë• TOTAL:${AMARILLO}${TOTAL_USUARIOS}${NC}   ${BLANCO}üñºÔ∏è SO:${AMARILLO}${SO_NAME}${NC}"
    echo -e "${AZUL}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"

    # Mostrar usuarios con 0 d√≠as
    if [[ ${#USUARIOS_EXPIRAN[@]} -gt 0 ]]; then
        echo -e "\n${ROJO}‚ö†Ô∏è USUARIOS QUE EXPIRAN HOY${NC}"
        echo -e "$(printf "%s  " "${USUARIOS_EXPIRAN[@]}")"
    fi
}
function crear_multiples_usuarios() {
    clear

    # Definir colores
    AZUL_SUAVE='\033[38;5;45m'
    SOFT_PINK='\033[38;5;211m'
    PASTEL_BLUE='\033[38;5;153m'
    LILAC='\033[38;5;183m'
    SOFT_CORAL='\033[38;5;217m'
    HOT_PINK='\033[38;5;198m'
    PASTEL_PURPLE='\033[38;5;189m'
    MINT_GREEN='\033[38;5;159m'
    NC='\033[0m'

    REGISTROS="/root/reg.txt"
    HISTORIAL="/root/log.txt"

    echo -e "${AZUL_SUAVE}===== üÜï CREAR M√öLTIPLES USUARIOS SSH =====${NC}"
    echo -e "${PASTEL_BLUE}üìù Formato: nombre contrase√±a d√≠as m√≥viles (separados por espacios, una l√≠nea por usuario)${NC}"
    echo -e "${PASTEL_BLUE}üìã Ejemplo: lucy 123 5 4${NC}"
    echo -e "${MINT_GREEN}‚úÖ Presiona Enter dos veces para confirmar.${NC}"

    declare -a usuarios
    while IFS= read -r linea && [ -n "$linea" ]; do
        usuarios+=("$linea")
    done

    if [ ${#usuarios[@]} -eq 0 ]; then
        echo -e "${HOT_PINK}‚ùå No se ingresaron usuarios. üíî${NC}"
        read -p "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}"
        return 1
    fi

    declare -A usuarios_existentes
    if [[ -f "$REGISTROS" ]]; then
        while IFS=: read -r user _; do
            if [[ -n "$user" && "$user" =~ ^[a-zA-Z0-9._-]+$ ]]; then
                usuarios_existentes["$user"]=1
            fi
        done < "$REGISTROS"
    fi

    # Control de duplicados en el input
    declare -A usuarios_input
    duplicados=0

    echo -e "${AZUL_SUAVE}===== üìã USUARIOS A CREAR =====${NC}"
    echo -e "${SOFT_CORAL}üë§ Usuario    üîë Clave      ‚è≥ D√≠as       üì± M√≥viles${NC}"
    echo -e "${LILAC}---------------------------------------------------------------${NC}"

    usuarios_validos=()
    for linea in "${usuarios[@]}"; do
        read -r USUARIO CLAVE DIAS MOVILES <<< "$linea"
        if [[ -z "$USUARIO" || -z "$CLAVE" || -z "$DIAS" || -z "$MOVILES" ]]; then
            echo -e "${HOT_PINK}‚ùå L√≠nea inv√°lida: $linea. Debe contener nombre, contrase√±a, d√≠as y m√≥viles. üíî${NC}"
            continue
        fi
        if [[ -n "${usuarios_input[$USUARIO]}" ]]; then
            echo -e "${HOT_PINK}‚ùå Usuario duplicado '$USUARIO' en el mismo bloque de entrada. üíî${NC}"
            ((duplicados++))
            continue
        fi
        usuarios_input["$USUARIO"]=1
        if ! [[ "$USUARIO" =~ ^[a-zA-Z_][a-zA-Z0-9_-]{0,31}$ ]]; then
            echo -e "${HOT_PINK}‚ùå Nombre de usuario inv√°lido '$USUARIO'. Solo letras, n√∫meros, guiones o guiones bajos (m√°x. 32 caracteres). üíî${NC}"
            continue
        fi
        if id "$USUARIO" &>/dev/null || [[ -n "${usuarios_existentes[$USUARIO]}" ]]; then
            echo -e "${HOT_PINK}‚ùå El usuario '$USUARIO' ya existe en el sistema o en $REGISTROS. üíî${NC}"
            continue
        fi
        if ! [[ "$DIAS" =~ ^[0-9]+$ && "$DIAS" -ge 0 && "$DIAS" -le 365 ]]; then
            echo -e "${HOT_PINK}‚ùå D√≠as inv√°lidos para '$USUARIO': $DIAS. Debe ser un n√∫mero entre 0 y 365. üíî${NC}"
            continue
        fi
        if ! [[ "$MOVILES" =~ ^[1-9][0-9]{0,2}$ && "$MOVILES" -le 999 ]]; then
            echo -e "${HOT_PINK}‚ùå M√≥viles inv√°lidos para '$USUARIO': $MOVILES. Debe ser un n√∫mero entre 1 y 999. üíî${NC}"
            continue
        fi
        printf "${PASTEL_BLUE}%-12s ${LILAC}%-12s ${MINT_GREEN}%-12s ${SOFT_PINK}%-12s${NC}\n" "$USUARIO" "$CLAVE" "$DIAS" "$MOVILES"
        usuarios_validos+=("$USUARIO:$CLAVE:$DIAS:$MOVILES")
    done

    if [ ${#usuarios_validos[@]} -eq 0 ]; then
        echo -e "${HOT_PINK}‚ùå No hay usuarios v√°lidos para crear. üíî${NC}"
        read -p "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}"
        return 1
    fi

    echo -e "${LILAC}===============================================================${NC}"

echo -ne "${MINT_GREEN}‚úÖ ¬øConfirmar creaci√≥n de estos usuarios? (s/n): ${NC}"
read confirmacion

if [[ "$confirmacion" != "s" && "$confirmacion" != "S" ]]; then
    echo -e "${PASTEL_PURPLE}üö´ Operaci√≥n cancelada. ‚ú®${NC}"
    echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}"
    read
    return 0
fi


    creados=0
    errores=0
    declare -a registros_nuevos
    declare -a historial_nuevos

    for linea in "${usuarios_validos[@]}"; do
        IFS=':' read -r USUARIO CLAVE DIAS MOVILES <<< "$linea"

        FECHA_CREACION=$(date +"%Y-%m-%d_%H-%M-%S")
        if [[ $DIAS -eq 0 ]]; then
            DIAS_EXPIRACION=1
        else
            DIAS_EXPIRACION=$((DIAS + 1))
        fi
        if ! EXPIRA_FECHA=$(date -d "+$DIAS_EXPIRACION days" +"%Y-%m-%d" 2>/dev/null); then
            echo -e "${HOT_PINK}‚ùå Error calculando la fecha de expiraci√≥n para '$USUARIO'. üíî${NC}"
            historial_nuevos+=("$(date '+%Y-%m-%d %H:%M:%S'):Error calculando la fecha de expiraci√≥n para '$USUARIO'.")
            ((errores++))
            continue
        fi
        FECHA_FORMAT=$(date -d "+$DIAS days" +"%d/%B/%Y" | awk '{print $1 "/" tolower($2) "/" $3}')

        # Intentar useradd con timeout
        if ! timeout 5 useradd -M -s /bin/false "$USUARIO" 2>/dev/null; then
            echo -e "${HOT_PINK}‚ùå Error creando usuario '$USUARIO' en el sistema. üíî${NC}"
            historial_nuevos+=("$(date '+%Y-%m-%d %H:%M:%S'):Error creando usuario '$USUARIO' en el sistema.")
            ((errores++))
            continue
        fi

        if ! echo "$USUARIO:$CLAVE" | chpasswd; then
            userdel -r "$USUARIO" 2>/dev/null
            echo -e "${HOT_PINK}‚ùå Error estableciendo contrase√±a para '$USUARIO'. üíî${NC}"
            historial_nuevos+=("$(date '+%Y-%m-%d %H:%M:%S'):Error estableciendo contrase√±a para '$USUARIO'.")
            ((errores++))
            continue
        fi

        if ! usermod -e "$EXPIRA_FECHA" "$USUARIO"; then
            userdel -r "$USUARIO" 2>/dev/null
            echo -e "${HOT_PINK}‚ùå Error configurando expiraci√≥n para '$USUARIO'. üíî${NC}"
            historial_nuevos+=("$(date '+%Y-%m-%d %H:%M:%S'):Error configurando expiraci√≥n para '$USUARIO'.")
            ((errores++))
            continue
        fi

        registros_nuevos+=("${USUARIO}:${CLAVE}:${FECHA_FORMAT}:${DIAS} d√≠as:${MOVILES}:${FECHA_CREACION}")

        if ! id "$USUARIO" &>/dev/null; then
            echo -e "${HOT_PINK}‚ùå Error: Fall√≥ la creaci√≥n de '$USUARIO' en el sistema. üíî${NC}"
            historial_nuevos+=("$(date '+%Y-%m-%d %H:%M:%S'):Error: Fall√≥ la creaci√≥n de '$USUARIO' en el sistema.")
            ((errores++))
            continue
        fi

        historial_nuevos+=("$(date '+%Y-%m-%d %H:%M:%S'):Usuario creado:$USUARIO")
        echo -e "${MINT_GREEN}‚úÖ Usuario $USUARIO creado exitosamente. ‚ú®${NC}"
        ((creados++))

        # Peque√±o retraso para evitar saturar el sistema
        sleep 0.1
    done

    # Escribir todos los registros y el historial
    if [ ${#registros_nuevos[@]} -gt 0 ]; then
        printf "%s\n" "${registros_nuevos[@]}" >> "$REGISTROS"
        sync
    fi
    if [ ${#historial_nuevos[@]} -gt 0 ]; then
        printf "%s\n" "${historial_nuevos[@]}" >> "$HISTORIAL"
        sync
    fi

    # Verificar registros escritos usando el arreglo en memoria
    for linea in "${registros_nuevos[@]}"; do
        USUARIO=$(echo "$linea" | cut -d':' -f1)
        usuarios_existentes["$USUARIO"]=1
        if ! grep -q "^$USUARIO:" "$REGISTROS"; then
            userdel -r "$USUARIO" 2>/dev/null
            echo -e "${HOT_PINK}‚ùå Error: Fall√≥ la escritura del registro de '$USUARIO' en $REGISTROS. üíî${NC}"
            historial_nuevos+=("$(date '+%Y-%m-%d %H:%M:%S'):Error: Registro de '$USUARIO' no se encontr√≥ en $REGISTROS tras escritura.")
            ((errores++))
            ((creados--))
        fi
    done
    if [ ${#historial_nuevos[@]} -gt 0 ]; then
        printf "%s\n" "${historial_nuevos[@]}" >> "$HISTORIAL"
        sync
    fi

    # Resumen mejorado con conteo de duplicados
    echo -e "${AZUL_SUAVE}===== üìä RESUMEN DE CREACI√ìN =====${NC}"
    echo -e "${MINT_GREEN}‚úÖ Usuarios creados exitosamente: $creados${NC}"
    echo -e "${HOT_PINK}‚ùå Usuarios con error: $errores${NC}"
    if [ $duplicados -gt 0 ]; then
        echo -e "${HOT_PINK}üö´ Usuarios duplicados en la entrada: $duplicados${NC}"
    fi
    echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}"
read
}
        

                function ver_registros() {
    clear

    # Definir colores
    AZUL_SUAVE='\033[38;5;45m'
    SOFT_PINK='\033[38;5;211m'
    PASTEL_BLUE='\033[38;5;153m'
    LILAC='\033[38;5;183m'
    SOFT_CORAL='\033[38;5;217m'
    HOT_PINK='\033[38;5;198m'
    PASTEL_PURPLE='\033[38;5;189m'
    MINT_GREEN='\033[38;5;159m'
    NC='\033[0m'

    REGISTROS="/root/reg.txt"

    echo -e "${AZUL_SUAVE}===== üå∏ REGISTROS =====${NC}"

    # Funci√≥n para centrar texto
    center_value() {
        local value="$1"
        local width="$2"
        local len=${#value}
        local padding_left=$(( (width - len) / 2 ))
        local padding_right=$(( width - len - padding_left ))
        printf "%*s%s%*s" "$padding_left" "" "$value" "$padding_right" ""
    }

    # Hora de corte fija: 8:50 AM
    CORTE="08:50:00"
    corte_hoy_secs=$(date -d "$(date '+%Y-%m-%d') $CORTE" +%s)
    ahora_secs=$(date +%s)

    if [[ -f $REGISTROS ]]; then
        # Encabezado
        printf "${SOFT_CORAL}%-3s ${PASTEL_BLUE}%-12s ${LILAC}%-12s ${PASTEL_PURPLE}%-12s ${MINT_GREEN}%10s ${SOFT_PINK}%-12s${NC}\n" \
            "N¬∫" "üë© Usuario" "üîí Clave" "üìÖ Expira" "$(center_value '‚è≥ D√≠as' 10)" "üì≤ M√≥viles"

        echo -e "${LILAC}-----------------------------------------------------------------------${NC}"

        NUM=1
        while IFS=':' read -r USUARIO CLAVE EXPIRA DIAS MOVILES CREADO EXTRA; do
            [[ -z "$USUARIO" ]] && continue
            [[ -z "$CLAVE" || -z "$EXPIRA" || -z "$DIAS" || -z "$MOVILES" ]] && continue

            if id "$USUARIO" &>/dev/null; then
                usuario_display="$USUARIO"
            else
                usuario_display="${USUARIO}${HOT_PINK}*${NC}"
            fi

            FORMATO_EXPIRA=$(echo "$EXPIRA" | awk -F'/' '{print $1 "/" $2 "/"}')
            DIAS_NUM=$(echo "$DIAS" | grep -oE '[0-9]+')

            if [[ -n "$CREADO" ]]; then
                if [[ "$CREADO" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{2}-[0-9]{2}-[0-9]{2}$ ]]; then
                    fecha_creacion=$(echo "$CREADO" | sed 's/_/ /; s/-/:/g')
                    fecha_creacion_secs=$(date -d "$fecha_creacion" +%s 2>/dev/null)
                else
                    fecha_creacion_secs=$(date -d "$CREADO" +%s 2>/dev/null)
                fi

                if [[ -z "$fecha_creacion_secs" ]]; then
                    fecha_creacion_secs=$(date +%s)
                    CREADO=$(date +"%Y-%m-%d_%H-%M-%S")
                    sed -i "s/^${USUARIO}:${CLAVE}:${EXPIRA}:${DIAS}:${MOVILES}:.*/${USUARIO}:${CLAVE}:${EXPIRA}:${DIAS}:${MOVILES}:${CREADO}/" "$REGISTROS"
                    sync
                fi

                # Calcular d√≠as transcurridos normalmente
                dias_transcurridos=$(( (ahora_secs - fecha_creacion_secs) / 86400 ))

                # Ajuste: si ya pasamos el corte y el usuario fue creado antes del corte ‚Üí restar un d√≠a ya
                if (( ahora_secs >= corte_hoy_secs && fecha_creacion_secs < corte_hoy_secs )); then
                    dias_transcurridos=$((dias_transcurridos + 1))
                fi

                (( dias_transcurridos < 0 )) && dias_transcurridos=0
                DIAS_RESTANTES=$(( DIAS_NUM - dias_transcurridos ))
                (( DIAS_RESTANTES < 0 )) && DIAS_RESTANTES=0
            else
                DIAS_RESTANTES="$DIAS_NUM"
                CREADO=$(date +"%Y-%m-%d_%H-%M-%S")
                sed -i "s/^${USUARIO}:${CLAVE}:${EXPIRA}:${DIAS}:${MOVILES}:.*/${USUARIO}:${CLAVE}:${EXPIRA}:${DIAS}:${MOVILES}:${CREADO}/" "$REGISTROS"
                sync
            fi

            DURACION_CENTRADA=$(center_value "$DIAS_RESTANTES" 10)

            printf "${SOFT_CORAL}%-3s ${PASTEL_BLUE}%-12s ${LILAC}%-12s ${PASTEL_PURPLE}%-12s ${MINT_GREEN}%-10s ${SOFT_PINK}%-12s${NC}\n" \
                "$NUM" "$usuario_display" "$CLAVE" "$FORMATO_EXPIRA" "$DURACION_CENTRADA" "$MOVILES"

            NUM=$((NUM+1))
        done < "$REGISTROS"

        [[ $NUM -eq 1 ]] && echo -e "${HOT_PINK}‚ùå No hay usuarios v√°lidos.${NC}"
    else
        echo -e "${HOT_PINK}‚ùå No hay registros a√∫n. El archivo '$REGISTROS' no existe.${NC}"
    fi

    echo -e "${LILAC}=====================${NC}"
    read -p "$(echo -e ${PASTEL_PURPLE}Presiona\ Enter\ para\ continuar...\ ‚ú®${NC})"
}
    
    
function mini_registro() {
    clear

    # Definir colores
    AZUL_SUAVE='\033[38;5;45m'
    SOFT_PINK='\033[38;5;211m'
    PASTEL_BLUE='\033[38;5;153m'
    LILAC='\033[38;5;183m'
    SOFT_CORAL='\033[38;5;217m'
    HOT_PINK='\033[38;5;198m'
    PASTEL_PURPLE='\033[38;5;189m'
    MINT_GREEN='\033[38;5;159m'
    NC='\033[0m'

    REGISTROS="/root/reg.txt"

    echo -e "${AZUL_SUAVE}===== üìã MINI REGISTRO =====${NC}"

    # Centrar texto en un ancho dado
    center_value() {
        local value="$1"
        local width="$2"
        local len=${#value}
        local padding_left=$(( (width - len) / 2 ))
        local padding_right=$(( width - len - padding_left ))
        printf "%*s%s%*s" "$padding_left" "" "$value" "$padding_right" ""
    }

    # Verificar si existe el archivo
    if [[ ! -f "$REGISTROS" || ! -s "$REGISTROS" ]]; then
        echo -e "${HOT_PINK}‚ùå No hay registros disponibles. üìÇ${NC}"
        read -p "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}"
        return 1
    fi

    # Encabezado
    printf "${PASTEL_BLUE}%-12s ${LILAC}%-12s ${MINT_GREEN}%10s ${SOFT_PINK}%-12s${NC}\n" \
        "üë§ Nombre" "üîë Contrase√±a" "$(center_value '‚è≥ D√≠as' 10)" "üì± M√≥viles"
    echo -e "${LILAC}--------------------------------------------${NC}"

    contador=0
    while IFS=':' read -r usuario clave expira dias moviles creado; do
        # Ignorar l√≠neas vac√≠as o malformadas
        [[ -z "$usuario" ]] && continue

        # Verificar si el usuario existe
        if id "$usuario" &>/dev/null; then
            usuario_display="$usuario"
        else
            usuario_display="${usuario}${HOT_PINK}*${NC}"
        fi

        # Extraer d√≠as num√©ricos
        dias_num=$(echo "$dias" | grep -oE '^[0-9]+')

        # Calcular d√≠as restantes
        if [[ -n "$creado" ]]; then
            # Manejar ambos formatos: "2025-08-09_10-49-50" y "2025-08-09 10:49:50"
            if [[ "$creado" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{2}-[0-9]{2}-[0-9]{2}$ ]]; then
                fecha_creacion=$(echo "$creado" | awk -F'[_-]' '{print $1"-"$2"-"$3" "$4":"$5":"$6}')
                fecha_creacion_secs=$(date -d "$fecha_creacion" +%s 2>/dev/null)
            else
                fecha_creacion_secs=$(date -d "$creado" +%s 2>/dev/null)
            fi
            if [[ -z "$fecha_creacion_secs" ]]; then
                # Si la conversi√≥n falla, usar la fecha actual y actualizar el registro
                fecha_creacion_secs=$(date +%s)
                creado=$(date +"%Y-%m-%d_%H-%M-%S")
                sed -i "s/^${usuario}:${clave}:${expira}:${dias}:${moviles}:.*/${usuario}:${clave}:${expira}:${dias}:${moviles}:${creado}/" "$REGISTROS"
                sync
            fi
            fecha_actual=$(date +%s)
            dias_transcurridos=$(( (fecha_actual - fecha_creacion_secs) / 86400 ))
            dias_restantes=$(( dias_num - dias_transcurridos ))
            [[ $dias_restantes -lt 0 ]] && dias_restantes=0
        else
            dias_restantes="$dias_num"
            creado=$(date +"%Y-%m-%d_%H-%M-%S")
            sed -i "s/^${usuario}:${clave}:${expira}:${dias}:${moviles}:.*/${usuario}:${clave}:${expira}:${dias}:${moviles}:${creado}/" "$REGISTROS"
            sync
        fi

        # Fila
        printf "${PASTEL_BLUE}%-12s ${LILAC}%-12s ${MINT_GREEN}%-10s ${SOFT_PINK}%-12s${NC}\n" \
            "$usuario_display" "$clave" "$(center_value "$dias_restantes" 10)" "$moviles"

        ((contador++))
    done < "$REGISTROS"

    if [[ $contador -eq 0 ]]; then
        echo -e "${HOT_PINK}‚ùå No hay usuarios existentes en el sistema. üíî${NC}"
    fi

    echo -e "${LILAC}============================================${NC}"
    echo -e "${SOFT_CORAL}TOTAL: ${contador} usuarios${NC}"
    read -p "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}"
}

    




function eliminar_usuario() {
    clear
    echo -e "${HOT_PINK}===== üí£ ELIMINAR USUARIO: NIVEL DIABLO - SAT√ÅN ROOT üî• =====${NC}"

    # Definir colores
    AZUL_SUAVE='\033[38;5;45m'
    SOFT_PINK='\033[38;5;211m'
    PASTEL_BLUE='\033[38;5;153m'
    LILAC='\033[38;5;183m'
    SOFT_CORAL='\033[38;5;217m'
    HOT_PINK='\033[38;5;198m'
    PASTEL_PURPLE='\033[38;5;189m'
    MINT_GREEN='\033[38;5;159m'
    AMARILLO='\033[38;5;220m'
    NC='\033[0m'

    echo -e "${PASTEL_BLUE}N¬∫      üë§ Usuario${NC}"
    echo -e "${LILAC}--------------------------${NC}"

    contador=1
    declare -A user_map

    # Leer usuarios del sistema (UID >= 1000 y != 65534 para excluir nobody)
    while IFS=: read -r username x uid gid desc home shell; do
        if (( uid >= 1000 && uid != 65534 )) && id "$username" &>/dev/null; then
            printf "${SOFT_CORAL}%-7d ${AMARILLO}%s${NC}\n" "$contador" "$username"
            user_map[$contador]="$username"
            ((contador++))
        fi
    done < /etc/passwd

    if [[ $contador -eq 1 ]]; then
        echo -e "${HOT_PINK}‚ùå No hay usuarios existentes para eliminar. üíî${NC}"
        read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
        return 1
    fi

    echo
    read -p "$(echo -e "${MINT_GREEN}üóëÔ∏è Ingrese los n√∫meros o nombres de usuarios a eliminar (separados por espacios)\n   (0 para cancelar): ${NC}")" input

    if [[ "$input" == "0" ]]; then
        echo -e "${PASTEL_PURPLE}üö´ Operaci√≥n cancelada.${NC}"
        read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
        return 0
    fi

    usuarios_a_eliminar=()
    for item in $input; do
        if [[ "$item" =~ ^[0-9]+$ ]] && [[ -n "${user_map[$item]}" ]]; then
            usuarios_a_eliminar+=("${user_map[$item]}")
        elif id "$item" &>/dev/null; then
            usuarios_a_eliminar+=("$item")
        fi
    done

    if [[ ${#usuarios_a_eliminar[@]} -eq 0 ]]; then
        echo -e "${HOT_PINK}‚ùå Ning√∫n usuario v√°lido seleccionado. üíî${NC}"
        read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
        return 1
    fi

    for usuario in "${usuarios_a_eliminar[@]}"; do
        # Terminar sesiones activas
        sesiones=$(loginctl list-sessions --no-legend | awk -v u="$usuario" '$3 == u {print $1}')
        for sesion in $sesiones; do
            loginctl terminate-session "$sesion"
        done
        sleep 1

        # Eliminar usuario del sistema
        if userdel -r -f "$usuario" 2>/dev/null; then
            # Remover del archivo de registros si existe
            [[ -f "$REGISTROS" ]] && sed -i "/^$usuario:/d" "$REGISTROS"
            echo "$(date '+%Y-%m-%d %H:%M:%S'):Usuario $usuario eliminado exitosamente." >> "$HISTORIAL"
            echo -e "${MINT_GREEN}‚úÖ Usuario $usuario eliminado correctamente.${NC}"
        else
            echo "$(date '+%Y-%m-%d %H:%M:%S'):Error al eliminar usuario $usuario del sistema." >> "$HISTORIAL"
            echo -e "${HOT_PINK}‚ùå Error al eliminar usuario $usuario. üíî${NC}"
        fi
    done

    read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
}




    

    

 


function nuclear_eliminar() {
    clear
    echo -e "${HOT_PINK}===== üí£ ELIMINACI√ìN COMPLETA DE USUARIOS (MODO NUCLEAR) =====${NC}"

    # Definir colores
    AZUL_SUAVE='\033[38;5;45m'
    SOFT_PINK='\033[38;5;211m'
    PASTEL_BLUE='\033[38;5;153m'
    LILAC='\033[38;5;183m'
    SOFT_CORAL='\033[38;5;217m'
    HOT_PINK='\033[38;5;198m'
    PASTEL_PURPLE='\033[38;5;189m'
    MINT_GREEN='\033[38;5;159m'
    AMARILLO='\033[38;5;220m'
    NC='\033[0m'

    if [[ ! -f "$REGISTROS" || ! -s "$REGISTROS" ]]; then
        echo -e "${HOT_PINK}‚ùå No hay registros disponibles. üìÇ${NC}"
        read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
        return 1
    fi

    echo
    echo -e "${PASTEL_BLUE}N¬∞  usuario${NC}"
    contador=1
    declare -A user_map
    while IFS=':' read -r usuario clave expira dias moviles creado; do
        printf "${SOFT_CORAL}%-3d ${AMARILLO}%s${NC}\n" "$contador" "$usuario"
        user_map[$contador]="$usuario"
        ((contador++))
    done < "$REGISTROS"

    if [[ $contador -eq 1 ]]; then
        echo -e "${HOT_PINK}‚ùå No hay usuarios para eliminar. üíî${NC}"
        read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
        return 1
    fi

    echo
    read -p "$(echo -e "${PASTEL_BLUE}üë§ Ingresa los n√∫meros o nombres de usuarios a eliminar (separados por espacio): ${NC}")" input

    if [[ -z "$input" ]]; then
        echo -e "${HOT_PINK}‚ùå No se seleccionaron usuarios. üíî${NC}"
        read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
        return 1
    fi

    usuarios_a_eliminar=()
    for item in $input; do
        if [[ "$item" =~ ^[0-9]+$ ]] && [[ -n "${user_map[$item]}" ]]; then
            usuarios_a_eliminar+=("${user_map[$item]}")
        elif grep -qiw "^$item:" "$REGISTROS"; then
            usuarios_a_eliminar+=("$item")
        fi
    done

    if [[ ${#usuarios_a_eliminar[@]} -eq 0 ]]; then
        echo -e "${HOT_PINK}‚ùå Ning√∫n usuario v√°lido seleccionado. üíî${NC}"
        read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
        return 1
    fi

    echo
    read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para confirmar la eliminaci√≥n...${NC}")"

    eliminados=""
    for usuario in "${usuarios_a_eliminar[@]}"; do
        # Cerrar sesiones activas del usuario con loginctl
        sesiones=$(loginctl list-sessions --no-legend | awk -v u="$usuario" '$3 == u {print $1}')
        for sesion in $sesiones; do
            loginctl terminate-session "$sesion"
        done

        # Breve pausa para asegurar cierre de sesiones
        sleep 1

        # Eliminar usuario forzadamente
        if ! userdel -r -f "$usuario" 2>/dev/null; then
            echo -e "${HOT_PINK}‚ùå Error al eliminar usuario $usuario del sistema. üíî${NC}"
            continue
        fi

        # Eliminar registro en archivo (insensible a may√∫sculas)
        if ! sed -i "/^$usuario:/Id" "$REGISTROS" 2>/dev/null; then
            echo -e "${HOT_PINK}‚ùå Error al eliminar el registro de $usuario en $REGISTROS. üíî${NC}"
            continue
        fi
        sync

        echo "$(date '+%Y-%m-%d %H:%M:%S'):Usuario $usuario eliminado completamente (modo nuclear)." >> "$HISTORIAL" 2>/dev/null
        eliminados+="$usuario "
    done

    if [[ -n "$eliminados" ]]; then
        echo -e "${MINT_GREEN}‚úÖ Usuarios ${eliminados% } eliminados completamente y sin residuos.${NC}"
    else
        echo -e "${HOT_PINK}‚ùå Error al eliminar usuarios. üíî${NC}"
    fi

    read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
}
        

    

    function centrar_texto() {
    local texto="$1"
    local ancho="$2"
    local relleno_total=$((ancho - ${#texto}))
    local relleno_izq=$((relleno_total / 2))
    local relleno_der=$((relleno_total - relleno_izq))
    printf "%*s%s%*s" "$relleno_izq" "" "$texto" "$relleno_der" ""
}


                    

       



    

    




    
function informacion_usuarios() {
    clear

    # Definir colores si a√∫n no est√°n
    ROSADO='\033[38;5;211m'
    LILA='\033[38;5;183m'
    TURQUESA='\033[38;5;45m'
    NC='\033[0m'

    echo -e "${ROSADO}üå∏‚ú®  INFORMACI√ìN DE CONEXIONES üíñ‚ú® üå∏${NC}"

    declare -A month_map=(
        ["Jan"]="enero" ["Feb"]="febrero" ["Mar"]="marzo" ["Apr"]="abril"
        ["May"]="mayo" ["Jun"]="junio" ["Jul"]="julio" ["Aug"]="agosto"
        ["Sep"]="septiembre" ["Oct"]="octubre" ["Nov"]="noviembre" ["Dec"]="diciembre"
    )

    if [[ ! -f "$HISTORIAL" ]]; then
        echo -e "${LILA}üòø ¬°Oh no! No hay historial de conexiones a√∫n, peque√±a! üíî${NC}"
        read -p "$(echo -e ${TURQUESA}Presiona Enter para seguir, coraz√≥n... üíå${NC})"
        return 1
    fi

    printf "${LILA}%-15s %-22s %-22s %-12s${NC}\n" "üë©‚Äçüíº Usuaria" "üå∑ Conectada" "üåô Desconectada" "‚è∞  Duraci√≥n"
    echo -e "${ROSADO}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${NC}"

    mapfile -t USUARIOS < <(awk -F'|' '{print $1}' "$HISTORIAL" | sort -u)

    for USUARIO in "${USUARIOS[@]}"; do
        if id "$USUARIO" &>/dev/null; then
            ULTIMO_REGISTRO=$(grep "^$USUARIO|" "$HISTORIAL" | tail -1)
            if [[ -n "$ULTIMO_REGISTRO" ]]; then
                IFS='|' read -r _ HORA_CONEXION HORA_DESCONECCION <<< "$ULTIMO_REGISTRO"

                if [[ "$HORA_CONEXION" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}:[0-9]{2}$ && \
                      "$HORA_DESCONECCION" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}:[0-9]{2}$ ]]; then

                    # Formatear fechas
                    CONEXION_FMT=$(date -d "$HORA_CONEXION" +"%d/%b %I:%M %p" 2>/dev/null)
                    DESCONEXION_FMT=$(date -d "$HORA_DESCONECCION" +"%d/%b %I:%M %p" 2>/dev/null)

                    for eng in "${!month_map[@]}"; do
                        esp=${month_map[$eng]}
                        CONEXION_FMT=${CONEXION_FMT/$eng/$esp}
                        DESCONEXION_FMT=${DESCONEXION_FMT/$eng/$esp}
                    done

                    # Convertir a segundos
                    SEC_CON=$(date -d "$HORA_CONEXION" +%s 2>/dev/null)
                    SEC_DES=$(date -d "$HORA_DESCONECCION" +%s 2>/dev/null)

                    if [[ -n "$SEC_CON" && -n "$SEC_DES" && $SEC_DES -ge $SEC_CON ]]; then
                        DURACION_SEG=$((SEC_DES - SEC_CON))
                        HORAS=$((DURACION_SEG / 3600))
                        MINUTOS=$(((DURACION_SEG % 3600) / 60))
                        SEGUNDOS=$((DURACION_SEG % 60))
                        DURACION=$(printf "%02d:%02d:%02d" $HORAS $MINUTOS $SEGUNDOS)
                    else
                        DURACION="N/A"
                    fi

                    # Mostrar fila
                    printf "${TURQUESA}%-15s %-22s %-22s %-12s${NC}\n" "$USUARIO" "$CONEXION_FMT" "$DESCONEXION_FMT" "$DURACION"
                fi
            fi
        fi
    done

    echo -e "${ROSADO}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${NC}"
    read -p "$(echo -e ${LILA}Presiona Enter para continuar, dulce... üåü${NC})"
}


 function bloquear_desbloquear_usuario() {
    clear
    echo -e "${AZUL_SUAVE}==== üîí BLOQUEAR/DESBLOQUEAR USUARIO ====${NC}"
    echo -e "${AZUL_SUAVE}===== üìã USUARIOS REGISTRADOS =====${NC}"

    # Definir colores
    AZUL_SUAVE='\033[38;5;45m'
    SOFT_PINK='\033[38;5;211m'
    PASTEL_BLUE='\033[38;5;153m'
    LILAC='\033[38;5;183m'
    SOFT_CORAL='\033[38;5;217m'
    HOT_PINK='\033[38;5;198m'
    PASTEL_PURPLE='\033[38;5;189m'
    MINT_GREEN='\033[38;5;159m'
    AMARILLO='\033[38;5;220m'
    NC='\033[0m'

    if [[ ! -f "$REGISTROS" ]]; then
        echo -e "${HOT_PINK}‚ùå No hay registros de usuarios. üìÇ${NC}"
        read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
        return 1
    fi

    # Mostrar encabezado con "Estado" en lugar de duraci√≥n
    printf "${PASTEL_BLUE}%-5s %-15s %-15s %-22s %-15s${NC}\n" \
        "N¬∫" "üë§ Usuario" "üîë Clave" "üìÖ Expira" "‚úÖ Estado"
    echo -e "${LILAC}--------------------------------------------------------------------------${NC}"

    declare -A usuarios
    declare -a nombres
    contador=1

    while IFS=':' read -r USUARIO CLAVE EXPIRA DURACION MOVILES PRIMER_LOGIN; do
        usuarios["$contador"]="$USUARIO"
        nombres+=("$USUARIO")

        # Verificar estado (bloqueado/desbloqueado) para mostrar en la lista
        if id "$USUARIO" &>/dev/null; then
            if grep -q "^$USUARIO:!" /etc/shadow; then
                ESTADO="bloqueado"
                COLOR_ESTADO="${HOT_PINK}"
            else
                ESTADO="desbloqueado"
                COLOR_ESTADO="${MINT_GREEN}"
            fi
        else
            ESTADO="desbloqueado"
            COLOR_ESTADO="${MINT_GREEN}"
        fi

        printf "${PASTEL_BLUE}%-5s %-15s ${SOFT_PINK}%-15s ${LILAC}%-22s ${COLOR_ESTADO}%-15s${NC}\n" \
            "$contador" "$USUARIO" "$CLAVE" "$EXPIRA" "$ESTADO"
        ((contador++))
    done < "$REGISTROS"

    echo -e "${LILAC}==========================================================================${NC}"
    read -p "$(echo -e "${PASTEL_PURPLE}üë§ Digite el n√∫mero o el nombre del usuario: ${NC}")" input

    # Validar entrada
    USUARIO=""
    if [[ "$input" =~ ^[0-9]+$ && -n "${usuarios[$input]}" ]]; then
        USUARIO="${usuarios[$input]}"
    elif [[ -n "$input" ]]; then
        for nombre in "${nombres[@]}"; do
            if [[ "$nombre" == "$input" ]]; then
                USUARIO="$input"
                break
            fi
        done
    fi

    if [[ -z "$USUARIO" ]]; then
        echo -e "${HOT_PINK}‚ùå Usuario '$input' no encontrado en los registros. üö´${NC}"
        read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
        return 1
    fi

    # Verificar si el usuario existe en el sistema
    USER_EXISTS=$(id "$USUARIO" &>/dev/null && echo "yes" || echo "no")

    # Verificar estado del usuario (solo si existe en el sistema)
    if [[ "$USER_EXISTS" == "yes" ]]; then
        if grep -q "^$USUARIO:!" /etc/shadow; then
            ESTADO="BLOQUEADO"
            COLOR_ESTADO="${HOT_PINK}"
            ACCION="desbloquear"
            ACCION_CONFIRM="Desea desbloquear al usuario '$USUARIO'? (s/n)"
        else
            ESTADO="DESBLOQUEADO"
            COLOR_ESTADO="${MINT_GREEN}"
            ACCION="bloquear"
            ACCION_CONFIRM="Desea bloquear al usuario '$USUARIO'? (s/n)"
        fi
    else
        ESTADO="DESBLOQUEADO (NO CREADO)"
        COLOR_ESTADO="${MINT_GREEN}"
        ACCION="bloquear"
        ACCION_CONFIRM="Desea bloquear al usuario '$USUARIO'? (s/n)"
    fi

    echo -e "${PASTEL_BLUE}íØ¢ El usuario '$USUARIO' est√° ${COLOR_ESTADO}${ESTADO}${NC}."
    read -p "$(echo -e "${PASTEL_PURPLE}‚úÖ $ACCION_CONFIRM ${NC}")" respuesta

    if [[ "$respuesta" =~ ^[Ss]$ ]]; then
        if [[ "$ESTADO" == "BLOQUEADO" ]]; then
            # Desbloquear usuario
            if [[ "$USER_EXISTS" == "yes" ]]; then
                usermod -U "$USUARIO" 2>/dev/null
                if [[ $? -eq 0 ]]; then
                    echo -e "${MINT_GREEN}üîì Usuario '$USUARIO' desbloqueado exitosamente. ‚úÖ${NC}"
                else
                    echo -e "${HOT_PINK}‚ùå Error al desbloquear al usuario '$USUARIO'. üö´${NC}"
                    read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
                    return 1
                fi
            else
                echo -e "${HOT_PINK}‚ùå El usuario '$USUARIO' no est√° creado en el sistema, no se puede desbloquear. üö´${NC}"
                read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
                return 1
            fi
        else
            # Bloquear usuario
            if [[ "$USER_EXISTS" == "yes" ]]; then
                usermod -L "$USUARIO" 2>/dev/null
                if [[ $? -eq 0 ]]; then
                    # Cerrar sesiones activas (SSH / Dropbear y loginctl)
                    CONEXIONES_SSH=$(ps -u "$USUARIO" -o pid=,comm= | grep "^[0-9]\+ sshd$" | awk '{print $1}')
                    CONEXIONES_DROPBEAR=$(ps -u "$USUARIO" -o pid=,comm= | grep "^[0-9]\+ dropbear$" | awk '{print $1}')
                    while IFS=' ' read -r SESSION _ _ USER _; do
                        if [[ "$USER" == "$USUARIO" ]]; then
                            loginctl terminate-session "$SESSION" 2>/dev/null
                        fi
                    done < <(loginctl list-sessions --no-legend)
                    for pid in $CONEXIONES_SSH $CONEXIONES_DROPBEAR; do
                        kill -9 "$pid" 2>/dev/null
                    done

                    echo -e "${MINT_GREEN}üîí Usuario '$USUARIO' bloqueado exitosamente y sesiones SSH terminadas. ‚úÖ${NC}"
                else
                    echo -e "${HOT_PINK}‚ùå Error al bloquear al usuario '$USUARIO'. üö´${NC}"
                    read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
                    return 1
                fi
            else
                echo -e "${HOT_PINK}‚ùå El usuario '$USUARIO' no est√° creado en el sistema, no se puede bloquear. üö´${NC}"
                read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
                return 1
            fi
        fi
    else
        echo -e "${SOFT_CORAL}‚ö†Ô∏è Operaci√≥n cancelada. üö´${NC}"
    fi

    read -p "$(echo -e "${PASTEL_PURPLE}Presiona Enter para continuar... ‚ú®${NC}")"
}


function configurar_banner_ssh() {
    clear
    echo -e "${VIOLETA}===== üéÄ CONFIGURAR BANNER SSH =====${NC}"
    echo -e "${AMARILLO}1) AGREGAR${NC}"
    echo -e "${AMARILLO}2) ELIMINAR${NC}"
    echo
    PROMPT=$(echo -e "${ROSA}‚û°Ô∏è Selecciona una opci√≥n: ${NC}")
    read -p "$PROMPT" SUBOP

    BANNER_FILE="/etc/ssh_banner"
    SSHD_CONFIG="/etc/ssh/sshd_config"

    case $SUBOP in
        1)
            clear
            echo -e "${VIOLETA}===== üéÄ AGREGAR BANNER SSH =====${NC}"
            echo -e "${AMARILLO}üìù Pega o escribe tu banner en formato HTML (puedes incluir colores, emojis, etc.).${NC}"
            echo -e "${AMARILLO}üìå Presiona Enter dos veces (l√≠nea vac√≠a) para terminar.${NC}"
            echo -e "${AMARILLO}üìå Ejemplo: <h2><font color=\"Red\">‚õÖ EST√ÅS USANDO UNA VPS PREMIUM üåà</font></h2>${NC}"
            echo -e "${AMARILLO}üìå Nota: Los saltos de l√≠nea dentro de una entrada ser√°n corregidos autom√°ticamente.${NC}"
            echo -e "${AMARILLO}üìå Aseg√∫rate de que tu cliente SSH (ej. PuTTY) est√© configurado para UTF-8 y soporte HTML.${NC}"
            echo

            # Arreglos para almacenar las l√≠neas del banner y el texto limpio
            declare -a BANNER_LINES
            declare -a PLAIN_TEXT_LINES
            LINE_COUNT=0
            TEMP_LINE=""
            PREVIOUS_EMPTY=false

            # Leer el banner l√≠nea por l√≠nea
            while true; do
                PROMPT=$(echo -e "${ROSA}‚û°Ô∏è L√≠nea $((LINE_COUNT + 1)): ${NC}")
                read -r INPUT_LINE

                # Verificar si es una l√≠nea vac√≠a (Enter)
                if [[ -z "$INPUT_LINE" ]]; then
                    if [[ "$PREVIOUS_EMPTY" == true ]]; then
                        # Dos Enters consecutivos, terminar entrada
                        if [[ -n "$TEMP_LINE" ]]; then
                            # Guardar la √∫ltima l√≠nea acumulada
                            CLEAN_LINE=$(echo "$TEMP_LINE" | tr -d '\n' | tr -s ' ')
                            BANNER_LINES[$LINE_COUNT]="$CLEAN_LINE"
                            PLAIN_TEXT=$(echo "$CLEAN_LINE" | sed -e 's/<[^>]*>//g' -e 's/&nbsp;/ /g')
                            PLAIN_TEXT_LINES[$LINE_COUNT]="$PLAIN_TEXT"
                            ((LINE_COUNT++))
                        fi
                        break
                    fi
                    PREVIOUS_EMPTY=true
                    continue
                fi

                PREVIOUS_EMPTY=false
                TEMP_LINE="$TEMP_LINE$INPUT_LINE"

                # Verificar si la l√≠nea contiene una etiqueta de cierre </h2> o </font>
                if [[ "$INPUT_LINE" =~ \</(h2|font)\> ]]; then
                    CLEAN_LINE=$(echo "$TEMP_LINE" | tr -d '\n' | tr -s ' ')
                    if [[ -z "$CLEAN_LINE" ]]; then
                        echo -e "${ROJO}‚ùå La l√≠nea no puede estar vac√≠a. Intenta de nuevo.${NC}"
                        TEMP_LINE=""
                        continue
                    fi
                    BANNER_LINES[$LINE_COUNT]="$CLEAN_LINE"
                    PLAIN_TEXT=$(echo "$CLEAN_LINE" | sed -e 's/<[^>]*>//g' -e 's/&nbsp;/ /g')
                    PLAIN_TEXT_LINES[$LINE_COUNT]="$PLAIN_TEXT"
                    ((LINE_COUNT++))
                    TEMP_LINE=""
                fi
            done

            if [[ $LINE_COUNT -eq 0 ]]; then
                echo -e "${ROJO}‚ùå No se ingresaron l√≠neas v√°lidas para el banner.${NC}"
                read -p "$(echo -e ${AZUL}Presiona Enter para continuar...${NC})"
                return
            fi

            # Mostrar vista previa y pedir confirmaci√≥n
            clear
            echo -e "${VIOLETA}===== üéÄ VISTA PREVIA DEL BANNER =====${NC}"
            echo -e "${CIAN}üìú As√≠ se ver√° el banner (sin etiquetas HTML, colores y emojis dependen del cliente SSH):${NC}"
            for ((i=0; i<LINE_COUNT; i++)); do
                echo -e "${PLAIN_TEXT_LINES[$i]}"
            done
            echo
            echo -e "${AMARILLO}‚ö†Ô∏è Nota: Aseg√∫rate de que tu cliente SSH (ej. PuTTY) use UTF-8 para ver emojis y soporte HTML para colores.${NC}"
            PROMPT=$(echo -e "${ROSA}‚û°Ô∏è ¬øConfirmar y guardar el banner? (s/n): ${NC}")
            read -p "$PROMPT" CONFIRM
            if [[ "$CONFIRM" != "s" && "$CONFIRM" != "S" ]]; then
                echo -e "${AMARILLO}‚ö†Ô∏è Configuraci√≥n de banner cancelada.${NC}"
                read -p "$(echo -e ${AZUL}Presiona Enter para continuar...${NC})"
                return
            fi

            # Crear el archivo del banner con codificaci√≥n UTF-8
            : > "$BANNER_FILE"  # Limpiar el archivo
            printf '\xEF\xBB\xBF' > "$BANNER_FILE"  # Agregar BOM para UTF-8
            for ((i=0; i<LINE_COUNT; i++)); do
                echo "${BANNER_LINES[$i]}" >> "$BANNER_FILE" 2>/dev/null || {
                    echo -e "${ROJO}‚ùå Error al crear el archivo $BANNER_FILE. Verifica permisos.${NC}"
                    read -p "$(echo -e ${AZUL}Presiona Enter para continuar...${NC})"
                    return
                }
            done

            # Configurar el banner en sshd_config
            if grep -q "^Banner" "$SSHD_CONFIG"; then
                sed -i "s|^Banner.*|Banner $BANNER_FILE|" "$SSHD_CONFIG" 2>/dev/null || {
                    echo -e "${ROJO}‚ùå Error al modificar $SSHD_CONFIG. Verifica permisos.${NC}"
                    read -p "$(echo -e ${AZUL}Presiona Enter para continuar...${NC})"
                    return
                }
            else
                echo "Banner $BANNER_FILE" >> "$SSHD_CONFIG" 2>/dev/null || {
                    echo -e "${ROJO}‚ùå Error al modificar $SSHD_CONFIG. Verifica permisos.${NC}"
                    read -p "$(echo -e ${AZUL}Presiona Enter para continuar...${NC})"
                    return
                }
            fi

            # Configurar el servidor SSH para aceptar UTF-8
            if ! grep -q "^AcceptEnv LANG LC_*" "$SSHD_CONFIG"; then
                echo "AcceptEnv LANG LC_*" >> "$SSHD_CONFIG" 2>/dev/null || {
                    echo -e "${ROJO}‚ùå Error al modificar $SSHD_CONFIG para UTF-8. Verifica permisos.${NC}"
                    read -p "$(echo -e ${AZUL}Presiona Enter para continuar...${NC})"
                    return
                }
            fi

            # Reiniciar el servicio SSH
            systemctl restart sshd >/dev/null 2>&1 || {
                echo -e "${ROJO}‚ùå Error al reiniciar el servicio SSH. Verifica manualmente.${NC}"
                read -p "$(echo -e ${AZUL}Presiona Enter para continuar...${NC})"
                return
            }

            echo -e "${VERDE}‚úÖ Banner SSH configurado exitosamente en $BANNER_FILE.${NC}"
            echo -e "${CIAN}üìú Contenido final del banner:${NC}"
            for ((i=0; i<LINE_COUNT; i++)); do
                echo -e "${PLAIN_TEXT_LINES[$i]}"
            done
            echo -e "${AMARILLO}‚ö†Ô∏è Nota: Configura tu cliente SSH (ej. PuTTY) con UTF-8 para ver emojis y verifica soporte HTML para colores.${NC}"
            read -p "$(echo -e ${AZUL}Presiona Enter para continuar...${NC})"
            ;;
        2)
            if grep -q "^Banner" "$SSHD_CONFIG"; then
                sed -i 's|^Banner.*|#Banner none|' "$SSHD_CONFIG" 2>/dev/null || {
                    echo -e "${ROJO}‚ùå Error al modificar $SSHD_CONFIG. Verifica permisos.${NC}"
                    read -p "$(echo -e ${AZUL}Presiona Enter para continuar...${NC})"
                    return
                }
                rm -f "$BANNER_FILE" 2>/dev/null
                systemctl restart sshd >/dev/null 2>&1 || {
                    echo -e "${ROJO}‚ùå Error al reiniciar el servicio SSH. Verifica manualmente.${NC}"
                    read -p "$(echo -e ${AZUL}Presiona Enter para continuar...${NC})"
                    return
                }
                echo -e "${VERDE}‚úÖ Banner SSH desactivado exitosamente.${NC}"
            else
                echo -e "${AMARILLO}‚ö†Ô∏è El banner ya est√° desactivado.${NC}"
            fi
            read -p "$(echo -e ${AZUL}Presiona Enter para continuar...${NC})"
            ;;
        *)
            echo -e "${ROJO}‚ùå ¬°Opci√≥n inv√°lida!${NC}"
            read -p "$(echo -e ${AZUL}Presiona Enter para continuar...${NC})"
            ;;
    esac
}


            
        
# Colores y emojis
VIOLETA='\033[38;5;141m'
VERDE='\033[38;5;42m'
AMARILLO='\033[38;5;220m'
AZUL='\033[38;5;39m'
ROJO='\033[1;31m'
CIAN='\033[38;5;51m'
FUCHSIA='\033[38;2;255;0;255m'
AMARILLO_SUAVE='\033[38;2;255;204;0m'
ROSA='\033[38;2;255;105;180m'
ROSA_CLARO='\033[1;95m'
NC='\033[0m'

# Men√∫ principal
if [[ -t 0 ]]; then
    while true; do
        clear
        barra_sistema
        echo
        echo -e "${VIOLETA}====== üòá PANEL DE USUARIOS VPN/SSH ======${NC}"
        echo -e "${AMARILLO_SUAVE}1. üÜï Crear usuario${NC}"
        echo -e "${AMARILLO_SUAVE}2. üìã Ver registros${NC}"
        echo -e "${AMARILLO_SUAVE}3. üóëÔ∏è Eliminar usuario${NC}"
        echo -e "${AMARILLO_SUAVE}4. üìä Informaci√≥n${NC}"
        echo -e "${AMARILLO_SUAVE}5. üü¢ Verificar usuarios online${NC}"
        echo -e "${AMARILLO_SUAVE}6. üîí Bloquear/Desbloquear usuario${NC}"
        echo -e "${AMARILLO_SUAVE}7. üÜï Crear m√∫ltiples usuarios${NC}"
        echo -e "${AMARILLO_SUAVE}8. üìã Mini registro${NC}"
        echo -e "${AMARILLO_SUAVE}9. üí£ Eliminar completamente usuario(s) (modo nuclear)${NC}"
        echo -e "${AMARILLO_SUAVE}10. üé® Configurar banner SSH${NC}"
        echo -e "${AMARILLO_SUAVE}0. üö™ Salir${NC}"
        PROMPT=$(echo -e "${ROSA}‚û°Ô∏è Selecciona una opci√≥n: ${NC}")
        read -p "$PROMPT" OPCION
        case $OPCION in
            1) crear_registro ;;
            2) ver_registros ;;
            3) nuclear_eliminar ;;
            4) informacion_usuarios ;;
            5) verificar_online ;;
            6) bloquear_desbloquear_usuario ;;
            7) crear_multiples_usuarios ;;
            8) mini_registro ;;
            9) eliminar_usuario ;;
            10) configurar_banner_ssh ;;
            0) exit 0 ;;
            *) echo -e "${ROJO}‚ùå ¬°Opci√≥n inv√°lida!${NC}"; read -p "$(echo -e ${ROSA_CLARO}Presiona Enter para continuar...${NC})" ;;
        esac
    done
fi
